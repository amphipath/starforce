output$inno[1:(n-f+3)] <- 1
output$hammer[(n-f+2):nrow(output)] <- 1
#generate probabilities when the hammer fails
hammerfailindex <- seq(n-f+2,nrow(output),3)
output$prob[hammerfailindex] <- (1 - ham) * choose(n,(f-1):0) * p^((n-f+1):n) * (1-p)^((f-1):0)
output$scroll[hammerfailindex] <- n
output$scroll[output$scroll == 0] <- n+1
output$failed[hammerfailindex] <- f:1
#generate probabilties when the hammer passes, and the next scroll fails
hammerthenfailindex <- seq(n-f+3,nrow(output),3)
output$prob[hammerthenfailindex] <- ham * choose(n,(f-1):0) * p^((n-f+1):n) * (1-p) ^ ((f):1)
output$failed[hammerthenfailindex] <- f:1
#generate probabilties when the hammer passes, and the next scroll passes
hammerthenpassindex <- seq(n-f+4,nrow(output),3)
output$prob[hammerthenpassindex] <- ham * choose(n,(f-1):0) * p^((n-f+2):(n+1)) * (1-p)^((f-1):0)
output$failed[hammerthenpassindex] <- (f-1):0
return(output)
}
## given a probability table, create an object that has all the properties we want
analyseProbs <- function(table,p,css,inno){
output <- list()
P <- sum(table$prob[table$inno == 0])
## Q is a random variable sampled from the inno'd outcmes.
Q <- table[table$inno == 1,]
Q$prob <- Q$prob / sum(Q$prob)
Qmeans <- c(sum(Q$scroll * Q$prob),sum(Q$prob * Q$hammer),0,0)
Qvars <- c(sum(Q$prob * (Q$scroll - Qmeans[1])^2),sum(Q$prob * (Q$hammer - Qmeans[2])^2),0,0)
## N is a random variable dictating how many times we inno before hitting on an "acceptable" outcome.
Nmean <- 1/P - 1
Nvar <- (1-P)/(P^2)
## CS is a random variable indicating the cost of filling a failed slot (in terms of scrolls and css's).
CSmean <- c(1/p,0,0,1 / css / p)
CSvar <- c((1-p)/p^2,0,0,(1 - css) / (css * css * p))
## A is a random variable indicating the state of an "acceptable" outcome
A <- table[table$inno == 0,]
A$prob <- A$prob / sum(A$prob)
CmeanMatrix <- (A$fail * A$prob) %*% t(CSmean)
Cmeans <- apply(CmeanMatrix,2,sum)
CvarMatrix <- (A$fail * A$prob) %*% t(CSvar)
Cvars <- apply(CvarMatrix,2,sum)
Ameans <- c(sum(A$scroll * A$prob),sum(A$prob * A$hammer),0,0)
Avars <- c(sum(A$prob * (A$scroll - Ameans[1])^2),sum(A$prob * (A$hammer - Ameans[2])^2),0,0)
## taking care of innos
innoMean <- c(0,0,1/inno,0)
innoVar <- c(0,0,(1 - inno)/inno^2,0)
totalMean <- Nmean*Qmeans + Nmean*innoMean  + Ameans + Cmeans
totalVar <- Nmean*Qvars + Nmean*innoVar + Avars + Cvars
output$tMean <- totalMean
output$tVar <- totalVar
return(output)
}
iterateF <- function(n,p,ham,css,inno) {
means <- numeric(n)
for(i in 1:n) {
m <- analyseProbs(probabilityTable(n,i,p,ham),p,css,inno)$tMean
means[i] <- sum(m * c(690,0,5000,2000))
}
}
iterateF(8,0.39,1,0.1,0.45)
iterateF <- function(n,p,ham,css,inno) {
means <- numeric(n)
for(i in 1:n) {
m <- analyseProbs(probabilityTable(n,i,p,ham),p,css,inno)$tMean
means[i] <- sum(m * c(690,0,5000,2000))
}
return(means)
}
iterateF(8,0.39,1,0.1,0.45)
analyseProbs(probabilityTable(8,5,0.39,1),0.39,0.1,0.45)
?qnorm
qnorm(0.99,1,0.05/2.3)
qnorm(0.99,1,0.05/2.326)
install.packages('e1071')
library(e1071); library(MASS)
n <- 100
set.seed(2018)
x <- rbind(mvnorm(n/2,c(2,-2),diag(2)),mvnorm(n/2,c(2,2),diag(2)))
y <- as.factor(rep(c(1,2), each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x2,x1,pch=20,col=y,asp=1))
n <- 100
set.seed(2018)
x <- rbind(mvrnorm(n/2,c(2,-2),diag(2)),mvrnorm(n/2,c(2,2),diag(2)))
y <- as.factor(rep(c(1,2), each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x2,x1,pch=20,col=y,asp=1))
n <- 100
set.seed(2018)
x <- rbind(mvrnorm(n/2,c(-2,-2),diag(2)),mvrnorm(n/2,c(2,2),diag(2)))
y <- as.factor(rep(c(1,2), each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x2,x1,pch=20,col=y,asp=1))
svm1 <- svm(y~x1+x2,data = dat,kernel = 'linear',cost = 1000)
summary(svm1)
x[svm1$index,]
plot(svm1,dat)
xnew <- rbind(mvrnorm(n/2,c(-2,-2),diag(2)),mvrnorm(n/2,c(2,2),diag(2)))
ynew <- rep(c(1,2),each = n/2)
ypred <- predict(svm1,xnew)
table(ypred,ynew)
sum(ynew != ypred) / length(ynew)
set.seed(2018)
x <- rbind(mvrnorm(n/2,c(-2,-2),diag(6)),mvrnorm(n/2,c(2,2),diag(6)))
y <- as.factor(rep(c(1,2),each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x1,x2,pch=20,col=y,asp=1))
set.seed(2018)
x <- rbind(mvrnorm(n/2,c(-2,-2),diag(6)),mvrnorm(n/2,c(2,2),diag(6)))
y <- as.factor(rep(c(1,2),each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x1,x2,pch=20,col=y,asp=1))
3*diag(2)
diag(2)
set.seed(2018)
x <- rbind(mvrnorm(n/2,c(-2,-2),3*diag(2)),mvrnorm(n/2,c(2,2),3*diag(2)))
y <- as.factor(rep(c(1,2),each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x1,x2,pch=20,col=y,asp=1))
svm2 <- svm(y~x1+x2,data = dat,kernel = 'linear',cost = 1)
summary(svm2)
plot(svm2,dat)
xnew <- rbind(mvrnorm(n/2,c(-2,-2),3*diag(2)),mvrnorm(n/2,c(2,2),3*diag(2)))
ynew <- rep(c(1,2),each=n/2)
ypred <- predict(svm2,xnew)
sum(ynew != ypred) / n
set.seed(2018)
x <- rbind(mvrnorm(n/2,c(-2,-2),3*diag(2)),mvrnorm(n/2,c(2,2),3*diag(2)))
y <- as.factor(rep(c(1,2),each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x1,x2,pch=20,col=y,asp=1))
svm2 <- svm(y~x1+x2,data = dat,kernel = 'linear',cost = 1000)
summary(svm2)
plot(svm2,dat)
xnew <- rbind(mvrnorm(n/2,c(-2,-2),3*diag(2)),mvrnorm(n/2,c(2,2),3*diag(2)))
ynew <- rep(c(1,2),each=n/2)
ypred <- predict(svm2,xnew)
sum(ynew != ypred) / n
set.seed(2018)
x <- rbind(mvrnorm(n/2,c(-2,-2),3*diag(2)),mvrnorm(n/2,c(2,2),3*diag(2)))
y <- as.factor(rep(c(1,2),each = n/2))
dat <- data.frame(x1 = x[,1],x2 = x[,2],y)
with(dat,plot(x1,x2,pch=20,col=y,asp=1))
svm2 <- svm(y~x1+x2,data = dat,kernel = 'linear',cost = 0.01)
summary(svm2)
plot(svm2,dat)
xnew <- rbind(mvrnorm(n/2,c(-2,-2),3*diag(2)),mvrnorm(n/2,c(2,2),3*diag(2)))
ynew <- rep(c(1,2),each=n/2)
ypred <- predict(svm2,xnew)
sum(ynew != ypred) / n
svm3 <- svm(y~x1+x2,data = dat, kernel = 'radial', gamma = 1,cost = 1000)
plot(svm3,dat)
ypred <- predivt(svm3,xnew)
sum(ynew!=ypred)
summary(svm3)
-3:3
tune.out <- tune(svm,y~x1+x2,data=dat,kernel = 'radial', ranges = list(cost = 10^c(-3:3),gamma = 10^c(-3:3)))
summary(tune.out)
tune.out <- tune(svm,y~x1+x2,data=dat,kernel = 'radial', ranges = list(cost = 10^c(-3:3),gamma = 10^c(-3:3)))
summary(tune.out)
svm3 <- svm(y~x1+x2,data = dat, kernel = 'radial', gamma = 1,cost = 1)
plot(svm3,dat)
ypred <- predict(svm3,xnew)
sum(ynew!=ypred)
summary(svm3)
ypred <- predict(svm3,xnew)
sum(ynew != ypred) / n
## Spelltrace Calculation Backend
probabilityTable <- function(n,f,p,ham) {
prob <- scroll <- hammer <- failed <- inno <- numeric(n + 2*f + 1)
output <- data.frame(prob,scroll,hammer,failed,inno)
# First calculate the situations where F fails are hit, prompting an inno
output$prob[1:(n-f+1)] <- choose((f-1):(n-1),(f-1)) * p^(0:(n-f)) * (1-p)^f
output$scroll[1:(n-f+1)] <- f:n
output$failed[1:(n-f+1)] <- f
#inno and hammer columns are easily specified without going into case-by-case
output$inno[1:(n-f+3)] <- 1
output$hammer[(n-f+2):nrow(output)] <- 1
#generate probabilities when the hammer fails
hammerfailindex <- seq(n-f+2,nrow(output),3)
output$prob[hammerfailindex] <- (1 - ham) * choose(n,(f-1):0) * p^((n-f+1):n) * (1-p)^((f-1):0)
output$scroll[hammerfailindex] <- n
output$scroll[output$scroll == 0] <- n+1
output$failed[hammerfailindex] <- f:1
#generate probabilties when the hammer passes, and the next scroll fails
hammerthenfailindex <- seq(n-f+3,nrow(output),3)
output$prob[hammerthenfailindex] <- ham * choose(n,(f-1):0) * p^((n-f+1):n) * (1-p) ^ ((f):1)
output$failed[hammerthenfailindex] <- f:1
#generate probabilties when the hammer passes, and the next scroll passes
hammerthenpassindex <- seq(n-f+4,nrow(output),3)
output$prob[hammerthenpassindex] <- ham * choose(n,(f-1):0) * p^((n-f+2):(n+1)) * (1-p)^((f-1):0)
output$failed[hammerthenpassindex] <- (f-1):0
return(output)
}
## given a probability table, create an object that has all the properties we want
analyseProbs <- function(table,p,css,inno){
output <- list()
P <- sum(table$prob[table$inno == 0])
## Q is a random variable sampled from the inno'd outcmes.
Q <- table[table$inno == 1,]
Q$prob <- Q$prob / sum(Q$prob)
Qmeans <- c(sum(Q$scroll * Q$prob),sum(Q$prob * Q$hammer),0,0)
Qvars <- c(sum(Q$prob * (Q$scroll - Qmeans[1])^2),sum(Q$prob * (Q$hammer - Qmeans[2])^2),0,0)
## N is a random variable dictating how many times we inno before hitting on an "acceptable" outcome.
Nmean <- 1/P - 1
Nvar <- (1-P)/(P^2)
## CS is a random variable indicating the cost of filling a failed slot (in terms of scrolls and css's).
CSmean <- c(1/p,0,0,1 / css / p)
CSvar <- c((1-p)/p^2,0,0,(1 - css) / (css * css * p))
## A is a random variable indicating the state of an "acceptable" outcome
A <- table[table$inno == 0,]
A$prob <- A$prob / sum(A$prob)
CmeanMatrix <- (A$fail * A$prob) %*% t(CSmean)
Cmeans <- apply(CmeanMatrix,2,sum)
CvarMatrix <- (A$fail * A$prob) %*% t(CSvar)
Cvars <- apply(CvarMatrix,2,sum)
Ameans <- c(sum(A$scroll * A$prob),sum(A$prob * A$hammer),0,0)
Avars <- c(sum(A$prob * (A$scroll - Ameans[1])^2),sum(A$prob * (A$hammer - Ameans[2])^2),0,0)
## taking care of innos
innoMean <- c(0,0,1/inno,0)
innoVar <- c(0,0,(1 - inno)/inno^2,0)
totalMean <- Nmean*Qmeans + Nmean*innoMean  + Ameans + Cmeans
totalVar <- Nmean*Qvars + Nmean*innoVar + Avars + Cvars
names(totalMean) <- names(totalVar) <- c('Scrolls','Hammers','Innos','Clean Slates')
output$tMean <- totalMean
output$tVar <- totalVar
return(output)
}
## Combining the above two functions
meanVars <- function(n,f,p,ham,css,inno){
table <- probabilityTable(n,f,p,ham)
return(analyseProbs(table,p,css,inno))
}
meanvarOutput <- function(n,f,p,ham,css,inno){
table <- probabilityTable(n,f,p,ham)
return(analyseProbs(table,p,css,inno))
}
scrollStats <- function(n,f,p,ham,css,inno){
table <- probabilityTable(n,f,p,ham)
return(analyseProbs(table,p,css,inno))
}
scrollStats(8,3,0.39,0.1,0.45)
scrollStats(8,3,0.39,1,0.1,0.45)
## Spelltrace Calculation Backend
probabilityTable <- function(n,f,p,ham) {
prob <- scroll <- hammer <- failed <- inno <- numeric(n + 2*f + 1)
output <- data.frame(prob,scroll,hammer,failed,inno)
# First calculate the situations where F fails are hit, prompting an inno
output$prob[1:(n-f+1)] <- choose((f-1):(n-1),(f-1)) * p^(0:(n-f)) * (1-p)^f
output$scroll[1:(n-f+1)] <- f:n
output$failed[1:(n-f+1)] <- f
#inno and hammer columns are easily specified without going into case-by-case
output$inno[1:(n-f+3)] <- 1
output$hammer[(n-f+2):nrow(output)] <- 1
#generate probabilities when the hammer fails
hammerfailindex <- seq(n-f+2,nrow(output),3)
output$prob[hammerfailindex] <- (1 - ham) * choose(n,(f-1):0) * p^((n-f+1):n) * (1-p)^((f-1):0)
output$scroll[hammerfailindex] <- n
output$scroll[output$scroll == 0] <- n+1
output$failed[hammerfailindex] <- f:1
#generate probabilties when the hammer passes, and the next scroll fails
hammerthenfailindex <- seq(n-f+3,nrow(output),3)
output$prob[hammerthenfailindex] <- ham * choose(n,(f-1):0) * p^((n-f+1):n) * (1-p) ^ ((f):1)
output$failed[hammerthenfailindex] <- f:1
#generate probabilties when the hammer passes, and the next scroll passes
hammerthenpassindex <- seq(n-f+4,nrow(output),3)
output$prob[hammerthenpassindex] <- ham * choose(n,(f-1):0) * p^((n-f+2):(n+1)) * (1-p)^((f-1):0)
output$failed[hammerthenpassindex] <- (f-1):0
return(output)
}
## given a probability table, create an object that has all the properties we want
analyseProbs <- function(table,p,css,inno){
output <- list()
P <- sum(table$prob[table$inno == 0])
## Q is a random variable sampled from the inno'd outcmes.
Q <- table[table$inno == 1,]
Q$prob <- Q$prob / sum(Q$prob)
Qmeans <- c(sum(Q$scroll * Q$prob),sum(Q$prob * Q$hammer),0,0)
Qvars <- c(sum(Q$prob * (Q$scroll - Qmeans[1])^2),sum(Q$prob * (Q$hammer - Qmeans[2])^2),0,0)
## N is a random variable dictating how many times we inno before hitting on an "acceptable" outcome.
Nmean <- 1/P - 1
Nvar <- (1-P)/(P^2)
## CS is a random variable indicating the cost of filling a failed slot (in terms of scrolls and css's).
CSmean <- c(1/p,0,0,1 / css / p)
CSvar <- c((1-p)/p^2,0,0,(1 - css) / (css * css * p))
## A is a random variable indicating the state of an "acceptable" outcome
A <- table[table$inno == 0,]
A$prob <- A$prob / sum(A$prob)
CmeanMatrix <- (A$fail * A$prob) %*% t(CSmean)
Cmeans <- apply(CmeanMatrix,2,sum)
CvarMatrix <- (A$fail * A$prob) %*% t(CSvar)
Cvars <- apply(CvarMatrix,2,sum)
Ameans <- c(sum(A$scroll * A$prob),sum(A$prob * A$hammer),0,0)
Avars <- c(sum(A$prob * (A$scroll - Ameans[1])^2),sum(A$prob * (A$hammer - Ameans[2])^2),0,0)
## taking care of innos
innoMean <- c(0,0,1/inno,0)
innoVar <- c(0,0,(1 - inno)/inno^2,0)
totalMean <- Nmean*Qmeans + Nmean*innoMean  + Ameans + Cmeans
totalVar <- Nmean*Qvars + Nmean*innoVar + Avars + Cvars
names(totalMean) <- names(totalVar) <- c('Scrolls','Hammers','Innos','Clean Slates')
output$tMean <- totalMean
output$tVar <- totalVar
output$tSd <- sqrt(totalVar)
return(output)
}
## Combining the above two functions
scrollStats <- function(n,f,p,ham,css,inno){
table <- probabilityTable(n,f,p,ham)
return(analyseProbs(table,p,css,inno))
}
scrollStats(8,3,0.39,1,0.1,0.45)
c()
shiny::runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
?type
runApp('C:/Users/user/Dropbox/starforce')
runApp('C:/Users/user/Dropbox/starforce')
install.packages('devtools')
install.packages('devtools')
devtools::install_github('rstudio/keras')
devtools::install_github('rstudio/keras')
install.packages('digest')
install.packages("digest")
devtools::install_github('rstudio/keras')
library(keras)
install_keras()
set.seed(2018)
n <- 10000
ntrain <- 6000
lw <- runif(n)
rw <- runif(n)
ld <- runif(n)
rd <- runif(n)
tilt <- as.factor(sign(rw*rd - lw*ld))
levels(tilt) <-c("L","R")
dat <- data.frame(tilt,lw,rw,ld,rd)
head(dat
)
x_train <- as.matrix(dat[1:ntrain,-1])
x_test <- as.matrix(dat[-(1:ntrain),-1])
y_train <- model.matrix(~tilt - 1,data = dat[1:ntrain,])
y_test <- model.matrix(~tilt - 1,data = dat[-(1:ntrain),])
y_train
c(4)
hidden_layer <- layer_dense(units = 10, activation = 'sigmoid', input_shape = c(4))
output_layer <- layer_dense(units = 2, activation = 'softmax')
model <- keras_model_sequential(list(hidden_layer, output_layer))
summary(model)
compile(model, optimizer = 'sgd', loss='categorical_crossentropy',metrics='acc')
fit(model,x_train,y_train,epochs = 20,batch_size = 10)
evaluate(model,x_test,y_test)
sum(runif(1000000) == 0)
k <- data.frame(a = c(0,0),b = c(0,0))
k
names(k) <- c('lol','lmao')
k
rownames(k) <- c('lol','lmao')
k
rownames(k)
k <- list()
k$'123 3' <- 3
k
names(k)
m <- '123 3'
k[m]
k[[m]]
?read.csv
k
k[['a']] <- 'b'
k
scrollStats <- function(n,f,p,ham,css,inno){
table <- probabilityTable(n,f,p,ham)
return(analyseProbs(table,p,css,inno))
}
## list of presets
presets <- list()
addPreset <- function(list, name, n, cost, p) {
list[[name]] <- data.frame(n = n, cost= cost, p = p)
}
presetTable <- read.csv('presets.csv',header=T)
for(i in 1:nrow(presetTable)) {
line <- presetTable[i,]
addPreset(presets, line$name, line$slots, line$cost, line$p)
}
getwd()
setwd('C:/Users/user/Dropbox/starforce')
scrollStats <- function(n,f,p,ham,css,inno){
table <- probabilityTable(n,f,p,ham)
return(analyseProbs(table,p,css,inno))
}
## list of presets
presets <- list()
addPreset <- function(list, name, n, cost, p) {
list[[name]] <- data.frame(n = n, cost= cost, p = p)
}
presetTable <- read.csv('presets.csv',header=T)
for(i in 1:nrow(presetTable)) {
line <- presetTable[i,]
addPreset(presets, line$name, line$slots, line$cost, line$p)
}
presetTable
presetTable <- read.csv('presets.csv',header=T)
presetTable
presetTable <- read.csv('presets.csv',header=T)
presetTable
presetTable <- read.csv('presets.csv',header=T)
presetTable
for(i in 1:nrow(presetTable)) {
line <- presetTable[i,]
addPreset(presets, line$name, line$slots, line$cost, line$p)
}
presets
presets <- list()
addPreset <- function(list, name, n, cost, p) {
list[[name]] <- data.frame(n = n, cost= cost, p = p)
return(list)
}
presetTable <- read.csv('presets.csv',header=T)
for(i in 1:nrow(presetTable)) {
line <- presetTable[i,]
presets <- addPreset(presets, line$name, line$slots, line$cost, line$p)
}
presets
prests
presets
line
line$name
presets <- list()
presetTable <- read.csv('presets.csv',header=T)
addPreset <- function(list, name, n, cost, p) {
list[[name]] <- data.frame(n = n, cost= cost, p = p)
return(list)
}
for(i in 1:nrow(presetTable)) {
line <- presetTable[i,]
presets <- addPreset(presets, as.character(line$name), line$slots, line$cost, line$p)
}
presets
shiny::runApp()
runApp()
runApp()
runApp()
feverDict <- list()
feverDict[[15]] <- 25
feverDict[[5]] <- 10
feverDict[[30]] <- 45
feverDict[[70]] <- 95
feverSub <- function(p) {
return(feverDict[[p]])
}
feverSub(15)
list(1=2)
feverDict
scrollStats(8,5,0.39,0.1,0.5)
scrollStats(8,5,0.39,0.5,0.1,0.5)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
as.numeric(T)
runApp()
meanTable
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
probabilityTable(8,6,0.39,0.5)
probabilityTable(8,6,0.39,0.1)
probabilityTable(8,6,0.39,1)
probabilityTable(8,6,0.39,0.5)
runApp()
min(1,2)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
index(5:10,5)
match(5,5:10)
runApp()
runApp()
runApp()
runApp()
runApp()
